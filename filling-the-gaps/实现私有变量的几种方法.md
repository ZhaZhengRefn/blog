# 实现私有变量的几种方法

## 命名约定
以下划线为属性名称的前缀，并没有什么卵用

## Symbol
私有变量名使用Symbol类型，假如外部无法访问Symbol值，那么也可以无法读取私有变量。但是可以使用```getOwnProperySymbols```或```Reflect.keys()```遍历
```js
const xSymbol = Symbol('x')
const ySymbol = Symbol('y')

class Foobar {
    constructor(x, y) {
        this[xSymbol] = x
        this[ySymbol] = y
    }

    toString() {
        console.log(`arguments: ${this[xSymbol]}-${this[ySymbol]}`)
    }

    get args() {
        return `${this[xSymbol]}--${this[ySymbol]}`
    }
}

const foobar = new Foobar(1, 2)

console.log(Object.getOwnPropertyNames(foobar))//[]

Object.getOwnPropertySymbols(foobar).forEach(k => {//1 2
    console.log(foobar[k])
})
Reflect.ownKeys(foobar).forEach(k => {//1 2
    console.log(foobar[k])
})
```

## WeakMap
将私有变量储存于WeakMap中。虽然仍然可以通过get接口读取存储在WeakMap中的实例的私有变量，但可以避免直接遍历实例读取出其中的私有属性。
用普通对象也可以实现，而使用WeakMap的原因在于: **可以防止内存泄露，假如实例其他引用被删除后，WeakMap对应键名会自动消失。**（详细可以看本目录的WeakMap笔记）
```js
const map = new WeakMap()

const internal = instance => {
    if(!map.has(instance)){
        map.set(instance, {})
    }
    return map.get(instance)
}

class Foobar {
    constructor(x, y) {
        internal(this).x = x
        internal(this).y = y
    }

    toString() {
        console.log(`arguments: ${internal(this).x}-${internal(this).y}`)
    }

    get args() {
        console.log(internal(this))
        return `${internal(this).x}--${internal(this).y}`
    }
}

const foobar = new Foobar(1, 2)

console.log(Object.getOwnPropertyNames(foobar))//[]
foobar.toString()//arguments: 1-2
```

## 闭包
通过闭包将数据封装在调用时创建的函数作用域，从而使外部无法访问

### 未封装前的类
未封装前的类，外部可以访问并修改传入的变量，非常不安全

#### In
```js
class Foo {
    constructor(x, y){
        this.x = x
        this.y = y
    }
    
    toString(){
        console.log(`arguments: ${this.x}-${this.y}`)
    }

    get args(){
        return `${this.x}--${this.y}`
    }
}
```

#### Out
```js
const foo = new Foo(1, 2)

foo.toString()//arguments: 1-2
foo.x = 4
foo.toString()//arguments: 4-2
```

### 初次尝试封装
实现封装后，变量仅能从内部，即类中访问。
#### In
```js
function Foo(...args){

    const this$ = {}//私有变量集

    class Foo {
        constructor(x, y){
            this$.x = x
            this$.y = y
        }

        toString(){
            console.log(`arguments: ${this$.x}-${this$.y}`)
        }

        get args(){
            return `${this$.x}--${this$.y}`
        }        
    }

    return new Foo(...args)
}
```

#### Out
```js
const foo = new Foo(1, 2)

foo.toString()//arguments: 1-2
foo.x = 4
foo.toString()//arguments: 1-2
```

### 修复instanceof操作符
使用第一次封装用的技术后，由于构造函数（外层Foo）返回的是一个新的对象（内层Foo的实例），因此instanceof操作符的结果可能会有误。
为了让结果更容易理解，我修改了内层类名。

#### 问题
```js
function Foo(...args) {

    const this$ = {} //私有变量集

    class Foobar {
        constructor(x, y) {
            this$.x = x
            this$.y = y
        }

        toString() {
            console.log(`arguments: ${this$.x}-${this$.y}`)
        }

        get args() {
            return `${this$.x}--${this$.y}`
        }
    }

    return new Foobar(...args)
}

const foo = new Foo(1,2)

console.log(foo instanceof Foo)//false
```

#### 原因
instanceof操作符返回的检测的是：实例的原型链上是否存在构造函数的原型，即
```js
function C(){}
const c = new C()
c instanceof C//true，因为Object.getPrototypeOf(c) === C.prototype
```
因此解决问题的方案很简单，将实例的原型设置为构造函数即可（注意，instanceof 只检测是否存在于原型链上）

#### In
```js
function Foo(...args) {

    const this$ = {} //私有变量集

    class Foobar {
        constructor(x, y) {
            this$.x = x
            this$.y = y
        }

        toString() {
            console.log(`arguments: ${this$.x}-${this$.y}`)
        }

        get args() {
            return `${this$.x}--${this$.y}`
        }
    }

    return Object.setPrototypeOf(new Foobar(...args), this)
}
```

#### Out
```js
const foo = new Foo(1,2)

console.log(foo instanceof Foo)//true
```

### 从丢失getter的现象来审视当前的原型链

#### 背景
使用上一步的方法封装私有变量，但是会发现其中的getter丢失了。
```js
const foo = new Foo(1,2)

console.log(foo.args)//undefined
```
首先来审视上一步封装方法背后的原型链是怎么样的：
```内部Foobar实例 -> 外部Foo -> Object```
原因在于，类中的getter-setter是挂载在原型上的，即```Foobar.prototype```。
因此重写Foobar实例的原型后，会丢失getter。

解决问题的答案也就很明显了，将Foobar原型就近挂载到原型链上。

#### In
```js
function Foo(...args) {

    const this$ = {} //私有变量集

    class Foobar {
        constructor(x, y) {
            this$.x = x
            this$.y = y
        }

        toString() {
            console.log(`arguments: ${this$.x}-${this$.y}`)
        }

        get args() {
            return `${this$.x}--${this$.y}`
        }
    }

    const instance = new Foobar(...args)
    Object.setPrototypeOf(Object.getPrototypeOf(instance), this)
    return instance
}
```
此时的原型链为：```Foobar(instance) -> Foobar.prototype -> Foo.prototype -> Object```

#### Out
```js
const foo = new Foo(1, 2)
console.log(foo.args)//arguments: 1-2
```

